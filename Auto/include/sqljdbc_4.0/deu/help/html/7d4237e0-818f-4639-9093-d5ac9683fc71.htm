<html xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:MSHelp="http://msdn.microsoft.com/mshelp"
	xmlns:mshelp="http://msdn.microsoft.com/mshelp"
	xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5"
	xmlns:msxsl="urn:schemas-microsoft-com:xslt">
<head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" />
<META NAME="save" CONTENT="history" />
<title>Spalten mit geringer Dichte</title>
<meta name="Language" content="de-de" />
<meta name="Microsoft.Help.Id"
	content="7d4237e0-818f-4639-9093-d5ac9683fc71" />
<meta name="Description"
	content="Spalten mit geringer Dichte sind gewöhnliche Spalten, die einen optimierten Speicher für NULL-Werte haben." />
<meta name="Microsoft.Help.ContentType" content="Concepts" />
<link rel="stylesheet" type="text/css" href="../local/Classic.css" />
<script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script>
<script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script>
<script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script>
<script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script>
<script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script>
<script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script>
<script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script>
<script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script>
</head>
<body>
	<div id="header">
		<table id="bottomTable" cellpadding="0" cellspacing="0">
			<tr>
				<td align="left"><span id="headerBold">Spalten mit
						geringer Dichte</span></td>
			</tr>
		</table>
		<table id="gradientTable">
			<tr>
				<td class="nsrBottom" background="../icons/gradient.gif" />
			</tr>
		</table>
	</div>
	<div id="mainSection">
		<div id="mainBody">
			<div class="introduction">
				<p>Spalten mit geringer Dichte sind gewöhnliche Spalten, die
					einen optimierten Speicher für NULL-Werte haben. Spalten mit
					geringer Dichte reduzieren die Speicherplatzanforderungen von
					NULL-Werten auf Kosten eines erhöhten Aufwands, um Werte ungleich
					NULL abzurufen. Verwenden Sie Spalten mit geringer Dichte, wenn
					dadurch mindestens 20 Prozent bis 40 Prozent Speicherplatz
					eingespart werden.</p>
				<p>
					In SQL Server JDBC Driver 3.0 werden bei der Herstellung einer
					Verbindung mit einem SQL Server 2008 (oder höher)-Server Spalten
					mit geringer Dichte unterstützt. Sie können <a
						href="f173fa5d-e114-4a37-a5c4-2baad9ff3af1.htm">SQLServerDatabaseMetaData.getColumns</a>,
					<a href="e2b0e0f7-717c-48e6-bcd2-a325d938a833.htm">SQLServerDatabaseMetaData.getFunctionColumns</a>
					oder <a href="4f0df8fe-3cd6-46e4-ae3c-dc23c35676b2.htm">SQLServerDatabaseMetaData.getProcedureColumns</a>
					verwenden, um zu ermitteln, welche Spalten geringe Dichte aufweisen
					und welche Spalte die festgelegte Spalte ist.
				</p>
				<p>Spaltensätze sind berechnete Spalten, die alle Spalten mit
					geringer Dichte im nicht typisierten XML-Format zurückgeben.
					Verwenden Sie Spaltensätze, wenn die Tabelle eine große Anzahl an
					Spalten (oder mehr als 1024 Spalten) enthält und es sehr aufwändig
					ist, einzelne Spalten mit geringer Dichte zu verarbeiten. Ein
					Spaltensatz kann bis zu 30 000 Spalten enthalten.</p>
			</div>
			<h1 class="heading">Beispiel</h1>
			<div id="sectionSection0" class="section" name="collapseableSection"
				style="">
				<h1 class="heading">Beschreibung</h1>
				<div class="subsection">
					<p>Dieses Beispiel zeigt, wie Spaltensätze erkannt werden. Des
						Weiteren zeigt es, wie die XML-Ausgabe eines Spaltensatzes
						analysiert wird, um die Daten aus den Spalten von geringer Dichte
						zu erhalten.</p>
					<p>Die erste Codeauflistung ist die Transact-SQL, die auf
						diesem Server ausgeführt werden sollte.</p>
					<p>Die zweite Codeauflistung ist der Java-Quellcode. Bevor Sie
						die Anwendung kompilieren, ändern Sie den Servernamen in der
						Verbindungszeichenfolge.</p>
				</div>
				<h1 class="heading">Code</h1>
				<div class="subsection">
					<div class="sampleCode">
						<span codeLanguage="other"><pre>use AdventureWorks
CREATE TABLE ColdCalling
(
ID int IDENTITY(1,1) PRIMARY KEY,
[Date] date,
[Time] time,
PositiveFirstName nvarchar(50) SPARSE,
PositiveLastName nvarchar(50) SPARSE,
SpecialPurposeColumns XML COLUMN_SET FOR ALL_SPARSE_COLUMNS
);
GO

INSERT ColdCalling ([Date], [Time])
VALUES ('10-13-09','07:05:24')
GO
      
INSERT ColdCalling ([Date], [Time], PositiveFirstName, PositiveLastName)
VALUES ('07-20-09','05:00:24', 'AA', 'B')
GO
      
INSERT ColdCalling ([Date], [Time], PositiveFirstName, PositiveLastName)
VALUES ('07-20-09','05:15:00', 'CC', 'DD')
GO</pre></span>
					</div>
				</div>
				<h1 class="heading">Code</h1>
				<div class="subsection">
					<div class="sampleCode">
						<span codeLanguage="other"><pre>import java.sql.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.xml.sax.InputSource;

import java.io.StringReader;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class SparseColumns {

   public static void main(String args[]) {
      final String connectionUrl = "jdbc:sqlserver://my_server;databaseName=AdventureWorks;integratedSecurity=true;";
      
      Connection conn = null;
      Statement stmt = null;
      ResultSet rs = null;
      
      try {
         conn = DriverManager.getConnection(connectionUrl);
         
         stmt = conn.createStatement();
         // Determine the column set column
         String columnSetColName = null;
         String strCmd = "SELECT name FROM sys.columns WHERE object_id=(SELECT OBJECT_ID('ColdCalling')) AND is_column_set = 1";
         rs = stmt.executeQuery(strCmd);
         
         if (rs.next()) {
            columnSetColName = rs.getString(1);
            System.out.println(columnSetColName + " is the column set column!");
         }
         rs.close();

         rs = null; 
             
         strCmd = "SELECT * FROM ColdCalling";
         rs = stmt.executeQuery(strCmd);
            
         // Iterate through the result set
         ResultSetMetaData rsmd = rs.getMetaData();
         
         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
         DocumentBuilder db = dbf.newDocumentBuilder();
         InputSource is = new InputSource();
         while (rs.next()) {
            // Iterate through the columns
            for (int i = 1; i &lt;= rsmd.getColumnCount(); ++i) {
               String name = rsmd.getColumnName(i);
               String value = rs.getString(i);
   
               // If this is the column set column
               if (name.equalsIgnoreCase(columnSetColName)) {
                  System.out.println(name);
                  
                  // Instead of printing the raw XML, parse it
                  if (value != null) {
                     // Add artificial root node "sparse" to ensure XML is well formed
                     String xml = "&lt;sparse&gt;" + value + "&lt;/sparse&gt;";
   
                     is.setCharacterStream(new StringReader(xml));
                     Document doc = db.parse(is);
   
                     // Extract the NodeList from the artificial root node that was added
                     NodeList list = doc.getChildNodes();
                     // This is the &lt;sparse&gt; node
                     Node root = list.item(0); 
                     // These are the xml column nodes
                     NodeList sparseColumnList = root.getChildNodes(); 
   
                     // Iterate through the XML document
                     for (int n = 0; n &lt; sparseColumnList.getLength(); ++n) {
                        Node sparseColumnNode = sparseColumnList.item(n);
                        String columnName = sparseColumnNode.getNodeName();
                        // Note that the column value is not in the sparseColumNode, it is the value of the first child of it
                        Node sparseColumnValueNode = sparseColumnNode.getFirstChild();
                        String columnValue = sparseColumnValueNode.getNodeValue();
                        
                        System.out.println("\t" + columnName + "\t: " + columnValue);
                     }
                  }
               } else {   // Just print the name + value of non-sparse columns
                  System.out.println(name + "\t: " + value);
               }
            }
            System.out.println();//New line between rows
         }
      } catch (Exception e) {
         e.printStackTrace();
      } finally {
         if (rs != null) {
            try {
               rs.close();
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
         if (stmt != null) {
            try {
               stmt.close();
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
         if (conn != null) {
            try {
               conn.close();
            } catch (Exception e) {
               e.printStackTrace();
            }
         }
      }
   }      
}</pre></span>
					</div>
				</div>
			</div>
			<span id="seeAlsoSpan"><h1 class="heading">Siehe auch</h1></span>
			<div id="seeAlsoSection" class="section" name="collapseableSection"
				style="">
				<div class="seeAlsoStyle">
					<span sdata="link"><a
						href="e1592499-b87b-45ee-bab8-beaba8fde841.htm">Verbessern von
							Leistung und Zuverlässigkeit mit dem JDBC-Treiber</a></span>
				</div>
			</div>
		</div>
		<div id="footer" class="section">
			<span id="feedbackarea">Senden Sie Microsoft <a
				href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dVielen%20Dank%20für%20Ihr%20Feedback.%20Die%20Autorenteams%20im%20Bereich%20Entwicklung%20nutzen%20Ihr%20Feedback,%20um%20die%20Dokumentation%20zu%20verbessern.%20Im%20Rahmen%20der%20Überprüfung%20Ihres%20Feedbacks%20erhalten%20Sie%20von%20uns%20ggf.%20eine%20E-Mail%20mit%20Rückfragen%20oder%20Feedback%20zur%20möglichen%20Lösung.%20Ihre%20E-Mail-Adresse%20wird%20von%20uns%20nicht%20zu%20anderen%20Zwecken%20verwendet%20und%20wird%20gelöscht,%20sobald%20die%20Überprüfung%20Ihres%20Feedbacks%20abgeschlossen%20ist.%0\AWeitere%20Informationen%20zu%20den%20Datenschutzrichtlinien%20von%20Microsoft%20finden%20Sie%20unter%20http://privacy.microsoft.com/de-de/default.aspx.%0\A%0\d','Kundenfeedback');">Feedback</a>
				zu diesem Thema.
			</span><span id="copyrightarea"><p>
					<a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012
						Microsoft. Alle Rechte vorbehalten.</a>
				</p></span>
		</div>
	</div>
</body>
</html>